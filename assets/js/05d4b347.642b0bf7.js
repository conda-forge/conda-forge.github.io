"use strict";(self.webpackChunkcf_infra_docs=self.webpackChunkcf_infra_docs||[]).push([[95108],{89171:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var a=n(95190),o=n(74848),r=n(28453);const i={authors:["wolfv"],tags:["infrastructure"]},s="Announcing the new recipe format on conda-forge",c={authorsImageUrls:[void 0]},l=[{value:"rattler-build and the v1 spec",id:"rattler-build-and-the-v1-spec",level:2},{value:"How to use the v1 recipe format on conda-forge",id:"how-to-use-the-v1-recipe-format-on-conda-forge",level:2},{value:"Transition plans",id:"transition-plans",level:2},{value:"Where to learn more",id:"where-to-learn-more",level:3}];function h(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["The conda-forge team is excited to announce that the v1 recipe format is available on conda-forge. The v1 recipe format is a community initiative dating back over 3 years to improve the recipe format for conda packages. If you are a maintainer of a feedstock on conda-forge, you have probably dealt with ",(0,o.jsx)(t.code,{children:"meta.yaml"})," files that conda-build utilizes. The file format has some limitations which is why the community has come together to come up with an improved version of the format: the v1 format."]}),"\n",(0,o.jsx)(t.h2,{id:"rattler-build-and-the-v1-spec",children:"rattler-build and the v1 spec"}),"\n",(0,o.jsx)(t.p,{children:"The v1 recipe format has a number of benefits:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["It always parses as valid YAML which makes it much easier to modify it with the bot infrastructure of conda-forge. While meta.yaml looks like YAML, it can contain Jinja logic that is incompatible with the YAML specification, which significantly complicates parsing and automated manipulation. Additionally, the new recipe format has ",(0,o.jsx)(t.a,{href:"https://github.com/prefix-dev/recipe-format/blob/main/schema.json",children:"a published JSON schema"})," which means that the editing experience in VS Code is greatly improved with contextual help."]}),"\n",(0,o.jsx)(t.li,{children:"The new recipe format enables much faster builds due to design decisions that eliminate the need for recursive parsing."}),"\n",(0,o.jsx)(t.li,{children:"Some features of conda-build, such as multiple outputs, had a lot of implicit behavior. We are fixing that in the v1 recipe."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"conda-forge uses rattler-build as its default build tool for the v1 recipe format. rattler-build currently has some significant benefits:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"rattler-build is built on top of rattler, a modern re-implementation of the conda standards in Rust, enabling extremely fast recipe builds."}),"\n",(0,o.jsx)(t.li,{children:"The log output of rattler-build is greatly improved, always showing the user what the final files in the package are and the final metadata."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["You can read much more about the v1 recipe format in the ",(0,o.jsx)(t.a,{href:"https://rattler.build",children:"https://rattler.build"})," docs and the two CEPs ",(0,o.jsx)(t.a,{href:"https://github.com/conda/ceps/blob/main/cep-0013.md",children:"CEP-0013"})," and ",(0,o.jsx)(t.a,{href:"https://github.com/conda/ceps/blob/main/cep-0014.md",children:"CEP-0014"}),". With the new format comes also a new build tool called ",(0,o.jsx)(t.a,{href:"https://github.com/prefix-dev/rattler-build",children:(0,o.jsx)(t.code,{children:"rattler-build"})})," which is developed by ",(0,o.jsx)(t.a,{href:"https://prefix.dev",children:(0,o.jsx)(t.code,{children:"prefix.dev"})}),". It is a reimplementation of conda-build in Rust, on top of the ",(0,o.jsx)(t.a,{href:"https://github.com/conda/rattler",children:(0,o.jsx)(t.code,{children:"rattler"})})," libraries."]}),"\n",(0,o.jsx)(t.p,{children:"A simple v1 recipe looks something like the following:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-yaml",children:'context:\n  # we define named variables in the context instead of `{$ set ... %}` directives\n  version: "23.0.0"\n\npackage:\n  name: "boltons"\n  # note that we use "GitHub" inspired syntax to access context / Jinja variables\n  version: ${{ version }}\n\nsource:\n  url: https://github.com/mahmoud/boltons/archive/refs/tags/${{ version }}.tar.gz\n  sha256: 9b2998cd9525ed472079c7dd90fbd216a887202e8729d5969d4f33878f0ff668\n\nbuild:\n  noarch: python\n  script:\n    - python -m pip install . --no-deps -vv\n\nrequirements:\n  host:\n    - python\n    - pip\n    - setuptools\n  run:\n    - pip\n\nabout:\n  license: BSD-3-Clause\n  license_file: LICENSE\n'})}),"\n",(0,o.jsx)(t.h2,{id:"how-to-use-the-v1-recipe-format-on-conda-forge",children:"How to use the v1 recipe format on conda-forge"}),"\n",(0,o.jsxs)(t.p,{children:["If you are adding a new recipe on staged-recipes, then it's easy: just submit a ",(0,o.jsx)(t.code,{children:"recipe.yaml"})," file instead of a ",(0,o.jsx)(t.code,{children:"meta.yaml"})," file.\nIn case you already maintain a feedstock, then the conversion can be semi-automated with a tool created by ",(0,o.jsx)(t.a,{href:"https://github.com/hadim",children:"Hadrien Mary"})," called ",(0,o.jsx)(t.a,{href:"https://github.com/hadim/feedrattler",children:(0,o.jsx)(t.code,{children:"feedrattler"})}),". The tool will take care of the basic conversions steps and uses ",(0,o.jsx)(t.a,{href:"https://github.com/conda-incubator/conda-recipe-manager",children:(0,o.jsx)(t.code,{children:"conda-recipe-manager"})})," by Anaconda / ",(0,o.jsx)(t.a,{href:"https://github.com/schuylermartin45",children:"Schuyler Martin"})," under the hood to parse the recipe and convert it to the new format."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-shell",children:"# One liner with Pixi\npixi exec feedrattler my-awesome-package-feedstock gh_user\n# With conda or mamba (as $CONDA)\n$CONDA create -n feedrattler feedrattler\n$CONDA activate feedrattler\nfeedrattler my-awesome-package-feedstock gh_user\n"})}),"\n",(0,o.jsx)(t.p,{children:"To do the conversion by hand, you need to do the following things:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["In the feedstock's ",(0,o.jsx)(t.code,{children:"conda-forge.yml"}),", add ",(0,o.jsx)(t.code,{children:"conda_build_tool: rattler-build"})]}),"\n",(0,o.jsxs)(t.li,{children:["Remove the ",(0,o.jsx)(t.code,{children:"meta.yaml"})," file and add a ",(0,o.jsx)(t.code,{children:"recipe.yaml"})," file following the v1 spec"]}),"\n",(0,o.jsxs)(t.li,{children:["Rerender the feedstock using ",(0,o.jsx)(t.code,{children:"conda-smithy rerender"})]}),"\n",(0,o.jsx)(t.li,{children:"Push your changes to your fork and open a PR to see the CI build your package"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"transition-plans",children:"Transition plans"}),"\n",(0,o.jsxs)(t.p,{children:["For the foreseeable future, conda-forge is going to support both formats, v1 and v0. We envision a gradual transition over at least one year to the new spec. There are a couple of places where the v1 spec also needs to finalize / stabilize. One notable place is the ",(0,o.jsx)(t.code,{children:"cache"}),"-based multi-output feature, where CEP discussions are ongoing. This stabilization in the format should happen within Q1 of 2025."]}),"\n",(0,o.jsx)(t.p,{children:'Since the beginning of 2025, the bot has gained more capabilities for the v1 format, such as automatically bumping versions (the "autotick-bot"). There are a number of other migrators and mini-migrators that need to be fully ported to the v1 spec before we can claim 100% compatibility with the conda-forge infrastructure.'}),"\n",(0,o.jsx)(t.p,{children:"As of today, over 700 of the 25000 recipes on conda-forge have been converted."}),"\n",(0,o.jsxs)(t.p,{children:["For now, the recommendation on staged-recipes is: if it's a simple ",(0,o.jsx)(t.code,{children:"noarch: python"})," recipe, it should probably be a ",(0,o.jsx)(t.code,{children:"v1"})," recipe. The same goes for ",(0,o.jsx)(t.code,{children:"Rust"})," or ",(0,o.jsx)(t.code,{children:"Go"})," projects that have a simple structure."]}),"\n",(0,o.jsx)(t.h3,{id:"where-to-learn-more",children:"Where to learn more"}),"\n",(0,o.jsxs)(t.p,{children:["There are very helpful docs located at ",(0,o.jsx)(t.a,{href:"https://rattler.build",children:"https://rattler.build"})," that explain the differences of the new recipe format pretty well. You are also very welcome to chat with us on the ",(0,o.jsx)(t.a,{href:"https://conda-forge.zulipchat.com/",children:"conda-forge Zulip"}),", or chat with the rattler-build developers on ",(0,o.jsx)(t.a,{href:"https://discord.gg/kKV8ZxyzY4",children:"their Discord"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"You can also read more about rattler-build and the v1 format in the following blog posts:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://prefix.dev/blog/rattler_build_on_conda_forge",children:"https://prefix.dev/blog/rattler_build_on_conda_forge"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://prefix.dev/blog/the_love_of_building_conda_packages",children:"https://prefix.dev/blog/the_love_of_building_conda_packages"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://prefix.dev/blog/rattler_build_a_new_parser",children:"https://prefix.dev/blog/rattler_build_a_new_parser"})}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var a=n(96540);const o={},r=a.createContext(o);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(r.Provider,{value:t},e.children)}},95190:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025/02/27/conda-forge-v1-recipe-support","editUrl":"https://github.com/conda-forge/conda-forge.github.io/tree/refs/heads/main/blog/2025-02-27-conda-forge-v1-recipe-support.md","source":"@site/blog/2025-02-27-conda-forge-v1-recipe-support.md","title":"Announcing the new recipe format on conda-forge","description":"The conda-forge team is excited to announce that the v1 recipe format is available on conda-forge. The v1 recipe format is a community initiative dating back over 3 years to improve the recipe format for conda packages. If you are a maintainer of a feedstock on conda-forge, you have probably dealt with meta.yaml files that conda-build utilizes. The file format has some limitations which is why the community has come together to come up with an improved version of the format: the v1 format.","date":"2025-02-27T00:00:00.000Z","tags":[{"inline":true,"label":"infrastructure","permalink":"/blog/tags/infrastructure"}],"readingTime":4.15,"hasTruncateMarker":true,"authors":[{"name":"Wolf Vollprecht","title":"Member of conda-forge/core","url":"https://github.com/wolfv","imageURL":"https://github.com/wolfv.png","key":"wolfv","page":null}],"frontMatter":{"authors":["wolfv"],"tags":["infrastructure"]},"unlisted":false,"nextItem":{"title":"Noarch variant packages for Python packages on conda-forge","permalink":"/blog/2024/10/15/python-noarch-variants"}}')}}]);