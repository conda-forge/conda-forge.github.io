"use strict";(globalThis.webpackChunkcf_infra_docs=globalThis.webpackChunkcf_infra_docs||[]).push([[51009],{15244(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"maintainer/understanding_conda_forge/compilation-concepts","title":"Compilation concepts","description":"There are two main models for source code to be executed on a particular system: it can either be","source":"@site/docs/maintainer/understanding_conda_forge/compilation-concepts.md","sourceDirName":"maintainer/understanding_conda_forge","slug":"/maintainer/understanding_conda_forge/compilation-concepts","permalink":"/docs/maintainer/understanding_conda_forge/compilation-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/conda-forge/conda-forge.github.io/tree/refs/heads/main/docs/maintainer/understanding_conda_forge/compilation-concepts.md","tags":[],"version":"current","lastUpdatedAt":1770466966000,"frontMatter":{"title":"Compilation concepts"},"sidebar":"diataxis","previous":{"title":"Emergencies","permalink":"/docs/how-to/emergencies"},"next":{"title":"Cross-compilation","permalink":"/docs/maintainer/understanding_conda_forge/cross-compilation"}}');var t=i(74848),a=i(28453);const s={title:"Compilation concepts"},o=void 0,l={},c=[{value:"The compilation pipeline",id:"the-compilation-pipeline",level:2},{value:"Build systems",id:"build-systems",level:2},{value:"Symbols",id:"symbols",level:2},{value:"API and ABI",id:"api-and-abi",level:2},{value:"Linking to libraries",id:"linking-to-libraries",level:2},{value:"Development files",id:"development-files",level:2},{value:"Binaries",id:"binaries",level:2},{value:"macOS Frameworks",id:"macos-frameworks",level:2},{value:"Shared library versioning",id:"shared-library-versioning",level:2},{value:"Finding shared libraries at runtime",id:"finding-shared-libraries-at-runtime",level:2},{value:"Architecture-dependent and architecture-independent packages",id:"architecture-dependent-and-architecture-independent-packages",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"There are two main models for source code to be executed on a particular system: it can either be\ncompiled into machine code, or interpreted. Programming languages such as C, C++ and Rust usually\nfollow the former path, requiring the source code to be compiled into machine code and then linked\ninto binaries that can be used directly, irrespective of the original sources. On the other hand,\nlanguages such as Python or shell script tend to be run via an interpreter that processes and runs\nthem directly from the source code. Both approaches have their advantages: compiling into machine\ncode can produce efficient stand-alone executables, at the cost of portability; on the other hand,\nan intepreter can run programs straight from sources and handle code changes immediately, at the\ncost of worse performance."}),"\n",(0,t.jsx)(n.p,{children:"Strictly speaking, programming languages aren't bound into compiler-interpreter dichotomy. There do\nexist interpreters for programming languages like C, and there do exist compilers that can turn\nPython code into stand-alone native executables. Nevertheless, they primarily follow a single model\nand packagers rarely need to be concerned about the alternative possibilities."}),"\n",(0,t.jsx)(n.p,{children:"Many programming languages fall somewhere across the compiler-interpreter spectrum. Many interpreted\nlanguages use Just-in-Time (JIT) compilation: rather than interpreting the input directly, they\ncompile it into machine code upon loading, achieving better performance with one-time startup cost.\nPython interpreters commonly compile source code into more efficient bytecode upon loading. On the\nother hand, Java sources need to be manually compiled into bytecode that is afterwards interpreted\nby a Java Virtual Machine."}),"\n",(0,t.jsx)(n.p,{children:"This document specifically focuses on the concepts related to languages compiled into machine code,\nsuch as C, C++ and Rust."}),"\n",(0,t.jsx)(n.h2,{id:"the-compilation-pipeline",children:"The compilation pipeline"}),"\n",(0,t.jsx)(n.p,{children:"A typical pipeline in a C-style language consists of three elements:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["A preprocessor, that is responsible for performing initial processing of the source code,\nhandling ",(0,t.jsx)(n.code,{children:"#include"})," statements and substituting macros. Preprocessing is usually done as part of\nthe compilation and is not visible to the user."]}),"\n",(0,t.jsxs)(n.li,{children:["A compiler backend, that is responsible for processing the source code and outputting object\nfiles (",(0,t.jsx)(n.code,{children:".o"})," on Unix, ",(0,t.jsx)(n.code,{children:".obj"})," on Windows), containing a compiled machine code or bytecode."]}),"\n",(0,t.jsx)(n.li,{children:"A linker (or link editor), that is responsible for combining multiple object files together,\nalong with the program's dependent libraries, and outputting the actual binary."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Typically, these programs are not run separately, but rather invoked automatically via the compiler\nfrontend. Usually, compiler frontends are invoked by build systems, from simple Makefiles to complex\nsolutions such as CMake or Meson. These often split compilation and linking steps, compiling every\nobject file separately to enable running multiple compiler processes simultaneously to benefit from\nmultiple logical CPUs."}),"\n",(0,t.jsx)(n.h2,{id:"build-systems",children:"Build systems"}),"\n",(0,t.jsx)(n.p,{children:"While for trivial projects, compiling software manually may be feasible, more realistically software\ninvolves a degree of complexity that justifies using a build system. A build system provides a layer\nof automation that takes care of compiling, testing and installing the software, at the same time\nproviding a degree of configurability for end users and providing support for multiple platforms and\ntoolchains."}),"\n",(0,t.jsx)(n.p,{children:"The build system pipeline typically involves four stages:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Configuration -- which covers accepting user input as to how the package should be built,\ndiscovering the necessary tooling and dependencies, and preparing the actual build."}),"\n",(0,t.jsx)(n.li,{children:"Compilation -- which covers compiling all source files into binaries, as well as any other\nnecessary processing. Many software packages can be run from the build directory after this\nstage."}),"\n",(0,t.jsx)(n.li,{children:"Testing -- which covers running the package's test suite to verify that is working correctly. In\nsome build system, tests are compiled in this stage; in others, they need to be enabled at\nconfiguration stage and built at compilation stage."}),"\n",(0,t.jsx)(n.li,{children:"Installation -- which covers installing compiled files and package's data files to the actual\nsystem, or a staging directory."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Projects usually adapt one of the existing build systems, such as GNU autotools, CMake or Meson.\nThese often are not entirely standalone tools but rather serve the purpose of configuring the build\nand generating build scripts for other tools, such as make, ninja or various Integrated Development\nEnvironments. These tools in turn consume the build scripts to perform the actual build."}),"\n",(0,t.jsx)(n.h2,{id:"symbols",children:"Symbols"}),"\n",(0,t.jsx)(n.p,{children:"The code written in C-style languages contains functions, global variables, etc. that are compiled\ninto what is collectively called symbols. The compiled binaries contain symbol tables that map the\nsymbol names into their compiled counterpart, and therefore enable programs to reference them across\ncode units and across different binaries. This enables not only splitting individual programs into\nseparate code files, but also creating libraries of code that can be used across different projects."}),"\n",(0,t.jsx)(n.p,{children:"These programming languages split interface and implementation. The compiled objects and binaries\ncontain the implementation, which is sufficient for already compiled programs to use them. However,\nin order to compile a new program, the compiler needs to additionally know the interface; for\nexample, the function prototype that provides the function name, arguments and return type."}),"\n",(0,t.jsx)(n.p,{children:"Typically, this split is accomplished through splitting the program code across two types of files:\nheader files specifying the interface, and source files containing the implementation. The source\nfiles are compiled into the actual binary, while header files are used during the compilation but\nalso distributed along with the compiled library afterwards."}),"\n",(0,t.jsx)(n.p,{children:"Note that in some cases the header files may contain implementation in addition to interface. For\nexample, the implementation of inline functions is provided in header files, so that the compiler\ncan use it while compiling other programs."}),"\n",(0,t.jsx)(n.h2,{id:"api-and-abi",children:"API and ABI"}),"\n",(0,t.jsx)(n.p,{children:"A C-style library essentially defines two related interfaces: an Application Programming Interface\n(API) that is used by the compiler, and an Application Binary Interface (ABI) that is used at\nruntime. Generally, the API is defined by the header files, and ABI is inferred from it. Both\nconcepts are critical for compatibility between libraries and the programs using them."}),"\n",(0,t.jsx)(n.p,{children:"APi defines the interface that is used in the source code of programs. Conversely, ABI is used by\ncompiled binaries. For example, consider a library with the following prototype:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"void foo(int32_t a);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Such a function accepts a single ",(0,t.jsx)(n.code,{children:"int32_t"})," parameter. From programmer's perspective, it can accept\nany parameter that can be converted into an ",(0,t.jsx)(n.code,{children:"int32_t"}),". However, from binary perspective the library\nhas a strict contract with the program that an ",(0,t.jsx)(n.code,{children:"int32_t"})," value must be passed."]}),"\n",(0,t.jsx)(n.p,{children:"Now consider that the library changes prototype into:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"void foo(int64_t a);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["From programmer's perspective this can be fine, as long as the previous ",(0,t.jsx)(n.code,{children:"int32_t"})," input can be\nconverted into ",(0,t.jsx)(n.code,{children:"int64_t"}),". However, the binary contract changes -- a previously compiled program\npasses an ",(0,t.jsx)(n.code,{children:"int32_t"})," type where a wider ",(0,t.jsx)(n.code,{children:"int64_t"})," type is expected now. This is a trivial example of\nan ABI breakage. If a program was compiled against the old prototype but used the new library,\nrunning it could lead to arbitrary results, from crashes to hard-to-debug bugs affecting other code\n(so-called Heisenbugs)."]}),"\n",(0,t.jsx)(n.p,{children:"Systems often feature mechanisms to protect against this class of issues. For example, shared\nlibraries often use various versioning schemes to ensure that the programs remain linked to a single\ncompatible version, and need to be recompiled to use the ABI from a new version."}),"\n",(0,t.jsx)(n.p,{children:"Note that ABI incompatibilities are not limited to deliberate changes of program interface. They can\nalso be caused by using different compilation parameters, different compilers or even compiler\nversions."}),"\n",(0,t.jsx)(n.h2,{id:"linking-to-libraries",children:"Linking to libraries"}),"\n",(0,t.jsxs)(n.p,{children:["In order to use a library, the program needs to link to it. It can link either statically or\ndynamically. Static linking means that the library code is embedded into the program directly, and\nthe library ",(0,t.jsx)(n.em,{children:"file"})," is no longer needed at runtime. Dynamic linking means that the program merely\ncarries a reference to an external library, and the library file is loaded when the program starts.\nBoth approaches to linking have their use cases, and their proponents."]}),"\n",(0,t.jsx)(n.p,{children:"Static linking creates a standalone program that is easier to distribute, and may benefit from\nadditional optimization as the optimizer is able to determine how the library is used exactly.\nHowever, statically linked programs are less space efficient, especially if the same library is used\nacross multiple programs. Since a specific library version is embedded into the program, the risk of\nbreakage on updates is minimized. However, this means that in order to update the library, the whole\npackage needs to be rebuilt, which may negatively impact security response time if the library turns\nout to be vulnerable."}),"\n",(0,t.jsx)(n.p,{children:"Dynamic linking creates programs that reuse a shared copy of the library. As such, the library\neither needs to be installed separately or distributed along with the program. However, their main\nadvantage is that the same library is shared across multiple packages, and can be quickly swapped\nfor another version as necessary. Unfortunately, this requires one to take special care for different\nlibrary versions to be compatible in the Application Binary Interface (ABI) exposed to programs."}),"\n",(0,t.jsx)(n.p,{children:"In conda-forge, dynamic linking to libraries provided by conda-forge packages is strongly preferred. Many of\nthe concerns related to dynamic linking do not apply here, as proper packaging practices\nensure that library dependencies are annotated and installed in compatible versions."}),"\n",(0,t.jsx)(n.h2,{id:"development-files",children:"Development files"}),"\n",(0,t.jsx)(n.p,{children:'Building against libraries requires additional development files to be available. In conda-forge,\nthese files may be distributed as part of the package installing the library itself; or split into\nseparate "development" packages, depending on criteria such as their complexity, popularity and\nsize.'}),"\n",(0,t.jsx)(n.p,{children:"The necessary development files include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"header files and include files, providing function prototypes and inline code from the library,"}),"\n",(0,t.jsx)(n.li,{children:"static libraries, needed for static linking,"}),"\n",(0,t.jsx)(n.li,{children:"shared libraries or import libraries, needed for dynamic linking,"}),"\n",(0,t.jsx)(n.li,{children:"pkg-config files or build system-specific files, used to indicate how to build against the\nlibrary."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Include files are installed into the ",(0,t.jsx)(n.code,{children:"include"})," directory or its subdirectories. They usually use\n",(0,t.jsx)(n.code,{children:".h"})," or ",(0,t.jsx)(n.code,{children:".inc"})," suffix for C. For C++, sometimes names without a suffix are used to follow the\nstandard library ",(0,t.jsx)(n.code,{children:"#include"})," scheme, or ",(0,t.jsx)(n.code,{children:".hpp"})," suffix."]}),"\n",(0,t.jsxs)(n.p,{children:["Static libraries are installed into the ",(0,t.jsx)(n.code,{children:"lib"})," directory and carry an ",(0,t.jsx)(n.code,{children:".a"})," suffix on Unix, or ",(0,t.jsx)(n.code,{children:".lib"}),"\non Windows. On Unix, shared libraries are used directly for linking, and they are described in the\n",(0,t.jsx)(n.a,{href:"#binaries",children:"binaries"})," section. On Windows, import libraries are used instead. They use ",(0,t.jsx)(n.code,{children:".lib"})," suffix\nlike static libraries."]}),"\n",(0,t.jsx)(n.p,{children:"Finally, packages often provide additional files that are used at build time to determine how to compile against\nthe library in question. For example, these can include pkg-config files, CMake files, autotools\nmacros. These files are usually used by the build systems."}),"\n",(0,t.jsx)(n.h2,{id:"binaries",children:"Binaries"}),"\n",(0,t.jsx)(n.p,{children:"The primary kind of artifacts produced by compiled programming languages are binaries. In this\ncontext, binaries mean files containing machine code. There are two main kind of binaries:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Executables: programs that can be run directly by the user."}),"\n",(0,t.jsx)(n.li,{children:"Shared libraries: collections of compiled code that programs usually link to and therefore they\nare loaded by programs at start time."}),"\n",(0,t.jsx)(n.li,{children:"Loadable modules: collections of compiled code that are loaded by programs at runtime (e.g.\nplugins)."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["On Unix platforms, executables don't feature any suffix, and common shells only start executables\nwhen their filename matches the specified command exactly. On Windows, executables commonly use\n",(0,t.jsx)(n.code,{children:".exe"})," suffix, and shells account for that. For example, the Python executable will be named\n",(0,t.jsx)(n.code,{children:"python"})," on Unixes, and ",(0,t.jsx)(n.code,{children:"python.exe"})," on Windows; in both cases, typing ",(0,t.jsx)(n.code,{children:"python"})," will execute it.\nExecutables are usually installed into the ",(0,t.jsx)(n.code,{children:"bin"})," directory, except on Windows where there may be\ninstalled into a variety of directories, including top-level Prefix directory and ",(0,t.jsx)(n.code,{children:"Scripts"})," tree."]}),"\n",(0,t.jsxs)(n.p,{children:["Shared libraries use filenames with a ",(0,t.jsx)(n.code,{children:"lib"})," prefix on Unixes, and ",(0,t.jsx)(n.code,{children:".so"})," suffix, except for macOS where they use\n",(0,t.jsx)(n.code,{children:".dylib"})," suffix instead. They are installed into the ",(0,t.jsx)(n.code,{children:"lib"})," directory. They often include a version\nstring to indicate ABI compatibility between different library versions, as explained in ",(0,t.jsx)(n.a,{href:"#shared-library-versioning",children:"shared\nlibrary versioning"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["On Windows, shared libraries use ",(0,t.jsx)(n.code,{children:".dll"})," suffix, and no obligatory prefix. They are installed along\nwith the executable programs (usually under ",(0,t.jsx)(n.code,{children:"bin"})," directory or equivalent). There is also no\nstandard filename versioning scheme, though many libraries include a version in the filename. The\n",(0,t.jsx)(n.code,{children:".dll"})," files are only used at runtime. To build programs against a shared library, an additional\nimport library of ",(0,t.jsx)(n.code,{children:".lib"})," format must be used, which essentially describes the (visible) content of a\n",(0,t.jsx)(n.code,{children:".dll"})," file to use."]}),"\n",(0,t.jsxs)(n.p,{children:['On most systems, loadable modules are the same file type as shared libraries. macOS is an exception\nto that: the binaries explicitly distinguish between shared libraries and "bundles", as loadable\nmodules are called. The recommended suffix for these files is ',(0,t.jsx)(n.code,{children:".bundle"}),", though much software\n(including Python) uses ",(0,t.jsx)(n.code,{children:".so"})," instead. They are usually installed into tool-specific directories."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:['The term "bundle" can be used both to refer to loadable binary files discussed here, and ',(0,t.jsx)(n.a,{href:"https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/Introduction/Introduction.html#//apple_ref/doc/uid/10000123i-CH1-SW1",children:"bundle\ndirectories"}),"\nused to encapsulate code and resources. These are distinct concepts, though there can be some\nconfusing overlap, as plugins may be distributed as bundle directories."]})}),"\n",(0,t.jsx)(n.h2,{id:"macos-frameworks",children:"macOS Frameworks"}),"\n",(0,t.jsxs)(n.p,{children:["In addition to the traditional Unix filesystem hierarchy where binaries and development files from\ndifferent packages are installed into shared ",(0,t.jsx)(n.code,{children:"bin"}),", ",(0,t.jsx)(n.code,{children:"include"}),", ",(0,t.jsx)(n.code,{children:"lib"}),', etc. directories, macOS\nfeatures a concept known as "frameworks". Frameworks constitute integrated packages combining\nshared libraries, development files and other resources in a single ',(0,t.jsx)(n.code,{children:".framework"})," directory."]}),"\n",(0,t.jsxs)(n.p,{children:["Frameworks are installed into ",(0,t.jsx)(n.code,{children:"/Library/Frameworks"})," and ",(0,t.jsx)(n.code,{children:"~/Library/Frameworks"})," directories.\nMultiple versions of the same framework can be installed simultaneously. They need to be explicitly\nincluded in projects (for example, using the ",(0,t.jsx)(n.code,{children:"-framework"})," compiler option)."]}),"\n",(0,t.jsx)(n.p,{children:"Conda-forge packages do not install frameworks. However, individual software may include system\nframeworks when built on macOS."}),"\n",(0,t.jsx)(n.h2,{id:"shared-library-versioning",children:"Shared library versioning"}),"\n",(0,t.jsxs)(n.p,{children:["Shared libraries are often versioned to indicate ",(0,t.jsx)(n.a,{href:"#api-and-abi",children:"ABI compatibility"}),". Typically, at\nleast two version components are used: a minor version that is incremented whenever\nbackwards-compatible ABI changes occur (e.g. new interfaces are added), and a major version that is\nincremented whenever backwards-incompatible changes happen. Often additional version components are\nused to indicate library updates without ABI changes."]}),"\n",(0,t.jsx)(n.p,{children:"When such a scheme is used, the installed library usually consists of three files:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["the actual library with a full version string, such as ",(0,t.jsx)(n.code,{children:"lib{name}.so.1.2.3"})," or\n",(0,t.jsx)(n.code,{children:"lib{name}.1.2.3.dylib"}),","]}),"\n",(0,t.jsxs)(n.li,{children:["a symbolic link including only the major version, such as ",(0,t.jsx)(n.code,{children:"lib{name}.so.1"})," or ",(0,t.jsx)(n.code,{children:"lib{name}.1.dylib"}),","]}),"\n",(0,t.jsxs)(n.li,{children:["an unversioned symbolic link, such as ",(0,t.jsx)(n.code,{children:"lib{name}.so"})," or ",(0,t.jsx)(n.code,{children:"lib{name}.dylib"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["When building a new program, the linker -- if passed ",(0,t.jsx)(n.code,{children:"-l{name}"})," -- uses the unversioned library\nname. If it is a symbolic link, it is resolved to the actual library. That library is used during\nthe linking process, and its ",(0,t.jsx)(n.em,{children:"contents"})," (not the filename pointed by the symbolic link) are used to\ndetermine the used library version."]}),"\n",(0,t.jsxs)(n.p,{children:["On Linux, an entry in the file, called ",(0,t.jsx)(n.code,{children:"DT_SONAME"}),' specifies what filename should be used to load\nthe library at runtime. Typically, it corresponds to the filename with the major version, though it\ncan be any filename, and e.g. libraries that do not provide cross-version compatibility at all often\nuse the full version. This name is often called "soname", and the version part itself is called\n"soversion".']}),"\n",(0,t.jsxs)(n.p,{children:["On macOS, library ",(0,t.jsx)(n.a,{href:"https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW23",children:"version\ninformation"}),'\nis used instead. It consists of a major version number, a minor (current) version number and a\ncompatibility version number. The major version number functions much like "soversion" -- it is used\nto construct the "major version" symbolic link and the install name, it can be any string and it\nneeds to change whenever backwards-incompatible changes occur. The minor version number consists of\none to three version components, and indicates the current library version; it usually starts with\nthe major number. The compatibility version number indicates the earliest version of the library\nthat remains compatible with programs compiled against the current version.']}),"\n",(0,t.jsx)(n.p,{children:"When a program is started, the library is loaded based on the major version number. Then, the loader\ncompares the current version number of the loaded library against the compatibility version of the\nlibrary used at link time (stored in the program). If the current version is older than the\ncompatibility version, the program refuses to start."}),"\n",(0,t.jsxs)(n.p,{children:["For example, a GNU-style ",(0,t.jsx)(n.code,{children:"lib{name}.so.1.2.3"})," would correspond to a major version of ",(0,t.jsx)(n.code,{children:"1"}),", current\nversion of ",(0,t.jsx)(n.code,{children:"1.2.3"})," and compatibility version of ",(0,t.jsx)(n.code,{children:"1.2.0"}),". Programs compiled against that version\nwould be compatible with ",(0,t.jsx)(n.code,{children:">=1.2.0,<2"}),", but the library would also remain compatible with programs\ncompiled against earlier versions. While Linux technically encodes the equivalent of compatibility\nversions in the filename, they aren't strictly enforced."]}),"\n",(0,t.jsx)(n.h2,{id:"finding-shared-libraries-at-runtime",children:"Finding shared libraries at runtime"}),"\n",(0,t.jsx)(n.p,{children:"Typically, a binary linked to a shared library does not embed the complete path to the library, but\nrather the library name. When a program is started, the dynamic loader is responsible for finding\nall the needed libraries, recursively, and loading them. The exact behavior differs from platform to\nplatform. Appropriately, the ways conda-forge builds binaries account for these differences."}),"\n",(0,t.jsxs)(n.p,{children:["The behavior of GNU/Linux dynamic loader is documented in the\n",(0,t.jsx)(n.a,{href:"https://manpages.debian.org/testing/manpages/ld.so.8.en.html",children:"ld.so(8) manpage"}),". The following\ndirectories are searched for dependent libraries (provided they do not specify a full path):"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["The directories specified in the ",(0,t.jsx)(n.code,{children:"DT_RPATH"})," entry of the program, provided ",(0,t.jsx)(n.code,{children:"DT_RUNPATH"})," is not\npresent. Specifying ",(0,t.jsx)(n.code,{children:"DT_RPATH"})," is discouraged, since the resulting behavior is suboptimal."]}),"\n",(0,t.jsxs)(n.li,{children:["The directories specified in the ",(0,t.jsx)(n.code,{children:"LD_LIBRARY_PATH"})," environment variable. This variable is\ntypically set locally when library search paths need to be overridden."]}),"\n",(0,t.jsxs)(n.li,{children:["The directories specified in the ",(0,t.jsx)(n.code,{children:"DT_RUNPATH"})," entry of the binary. Note that these paths do not\napply recursively -- the program's ",(0,t.jsx)(n.code,{children:"DT_RUNPATH"})," is used for the libraries used directly by the\nprogram, and these libraries's entries are used for their own dependent libraries, and so on."]}),"\n",(0,t.jsx)(n.li,{children:"The standard system search paths."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Furthermore, the paths in ",(0,t.jsx)(n.code,{children:"DT_RPATH"})," and ",(0,t.jsx)(n.code,{children:"DT_RUNPATH"})," can use the ",(0,t.jsx)(n.code,{children:"$ORIGIN"})," placeholder to reference\nthe directory containing the binary. Conda-forge packages typically ensure that the correct\nlibraries are used by embedding a ",(0,t.jsx)(n.code,{children:"DT_RUNPATH"})," pointing to the appropriate directory within the\nconda-forge environment, usually ",(0,t.jsx)(n.code,{children:"$ORIGIN/../lib"}),". This can be done e.g. by linking with\n",(0,t.jsx)(n.code,{children:"-Wl,-rpath,\\$ORIGIN/../lib"})," flag."]}),"\n",(0,t.jsxs)(n.p,{children:["On macOS, the equivalent behavior is achieved using ",(0,t.jsx)(n.a,{href:"https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/RunpathDependentLibraries.html",children:"Run-Path Dependent\nLibraries"}),".\nLibraries are created with install names conaining a ",(0,t.jsx)(n.code,{children:"@rpath/"})," path prefix, e.g.\n",(0,t.jsx)(n.code,{children:"@rpath/libpython3.15.dylib"}),", and therefore such names are embedded in the binaries linking to them.\nAs described in the ",(0,t.jsx)(n.a,{href:"https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW21",children:"library search\nprocess"}),",\nthe dynamic loader searches in the following directories (since the name contains a slash):"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["The directories specified in the ",(0,t.jsx)(n.code,{children:"DYLD_LIBRARY_PATH"})," environment variable."]}),"\n",(0,t.jsxs)(n.li,{children:["The specified path, with ",(0,t.jsx)(n.code,{children:"@rpath"})," being substituted for the library's run path."]}),"\n",(0,t.jsxs)(n.li,{children:["The directories specified in the ",(0,t.jsx)(n.code,{children:"DYLD_FALLBACK_LIBRARY_PATH"})," environment variable, that defaults\nto system library directories."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The run paths in binaries specify the appropriate conda-forge environment directory using a\n",(0,t.jsx)(n.code,{children:"@loader_path"})," placeholder, such as ",(0,t.jsx)(n.code,{children:"@loader_path/../lib"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order",children:"Windows Dynamic-link library search\norder"})," is\nquite complex. However, for our purposes it suffices to list the following variants:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:'A number of overrides such as "DLL Redirection" and "Known DLLs".'}),"\n",(0,t.jsx)(n.li,{children:"The directory containing the application."}),"\n",(0,t.jsx)(n.li,{children:"A number of system directories."}),"\n",(0,t.jsx)(n.li,{children:"The current directory."}),"\n",(0,t.jsxs)(n.li,{children:["The directories listed in the ",(0,t.jsx)(n.code,{children:"PATH"})," environment variable."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Note that steps 2. and 5. specifically focus on program directories. To account for this,\nconda-forge generally installs ",(0,t.jsx)(n.code,{children:".dll"})," libraries into program directories such as the ",(0,t.jsx)(n.code,{children:"bin"})," directory\nrather than the ",(0,t.jsx)(n.code,{children:"lib"})," directory used on Unixes."]}),"\n",(0,t.jsx)(n.h2,{id:"architecture-dependent-and-architecture-independent-packages",children:"Architecture-dependent and architecture-independent packages"}),"\n",(0,t.jsxs)(n.p,{children:["Conda-forge packages can be built for specific architectures, or made architecture-independent, also\nknown as ",(0,t.jsx)(n.code,{children:"noarch"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"When C code is compiled into binaries containing machine code and installs them needs to be\nseparately built for every supported platform. Therefore, it is distributed as\narchitecture-dependent packages. The Python language interpreter is an example of such software."}),"\n",(0,t.jsxs)(n.p,{children:["A package that installs only data files and interpreted scripts can be made\narchitecture-independent. It can be built on any supported platform, and the build should always\nresult in the same files being installed, irrespective of platform used to perform it. An example of\nthis is a so-called pure Python package, i.e. a distribution that installs ",(0,t.jsx)(n.code,{children:".py"})," modules and\nno compiled extensions. The equivalent Python packaging concept is a ",(0,t.jsx)(n.code,{children:"*-none-any.whl"})," package."]}),"\n",(0,t.jsxs)(n.p,{children:["A special case of this are pure Python packages with entry points. Installed entry points are\nplatform-specific: on Unixes they are pure Python scripts, but on Windows they are compiled\nexecutables. In order to facilitate ",(0,t.jsx)(n.code,{children:"noarch: python"})," packaging for them, entry points are stored not\nas final executables, but as the original list. When the package is installed, they are recreated in\nthe appropriate platform-specific format."]}),"\n",(0,t.jsxs)(n.p,{children:["Conversely, a Python distribution that installs compiled extension modules in addition to ",(0,t.jsx)(n.code,{children:".py"}),"\nmodules needs to be built for every platform separately, and requires using arch-dependent packages.\nFurthermore, since Python extensions interface with the Python interpreter, they also need to be\nconcerned about ABI compatibility with it. Python exposes two kinds of ABI: the regular extension\nABI and the stable ABI."]}),"\n",(0,t.jsx)(n.p,{children:"The regular extension ABI preserves compatibility across patch releases of the Python interpreter,\nbut is not compatible across major or minor versions. For example, an extension compiled against\nPython 3.12 cannot be used on 3.11 or 3.13. Appropriately, the respective conda-forge package needs\nto be built not only for all supported platforms, but also as separate variants for all supported\nPython versions. At the time of writing, NumPy is an example of such a package."}),"\n",(0,t.jsxs)(n.p,{children:["The stable ABI, on the other hand, guarantees forward compatibility with future minor releases of\nPython. Therefore, an extension built for the stable ABI of Python 3.12 can be successfully used on\nPython 3.13 and 3.14 (but not 3.11). This is represented by ",(0,t.jsx)(n.code,{children:"*-abi3-*.whl"})," Python packages. In\nconda-forge, such packages are built for the oldest supported Python version, and therefore are\nindependent of Python version. However, they are still architecture-dependent. An example of such a\npackage is rustworkx."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453(e,n,i){i.d(n,{R:()=>s,x:()=>o});var r=i(96540);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);