"use strict";(self.webpackChunkcf_infra_docs=self.webpackChunkcf_infra_docs||[]).push([[42026],{95217:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>u,contentTitle:()=>h,default:()=>f,frontMatter:()=>d,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"how-to/advanced/cross-compilation","title":"Cross-compilation","description":"Cross-compiling means building a package for a different architecture or a different operating","source":"@site/docs/how-to/advanced/cross-compilation.mdx","sourceDirName":"how-to/advanced","slug":"/how-to/advanced/cross-compilation","permalink":"/docs/how-to/advanced/cross-compilation","draft":false,"unlisted":false,"editUrl":"https://github.com/conda-forge/conda-forge.github.io/tree/refs/heads/main/docs/how-to/advanced/cross-compilation.mdx","tags":[],"version":"current","lastUpdatedAt":1767826813000,"frontMatter":{"title":"Cross-compilation"},"sidebar":"diataxis","previous":{"title":"Talk to the bots","permalink":"/docs/how-to/advanced/talk-to-the-bots"},"next":{"title":"Maintain several versions","permalink":"/docs/how-to/advanced/several-versions"}}');var t=i(74848),o=i(28453),r=i(11470),l=i(19365);function a({children:e}){if(2!==e.length)throw new Error(`RecipeTabs must have exactly two children, but received ${e.length}.`);return(0,t.jsxs)(r.A,{groupId:"synced-recipe-tabs",children:[(0,t.jsx)(l.A,{label:"v0 (meta.yaml)",value:"v0",children:e[0]}),(0,t.jsx)(l.A,{label:"v1 (recipe.yaml)",value:"v1",default:"True",children:e[1]})]})}function c({children:e}){if(2!==e.length)throw new Error(`BuildScriptTabs must have exactly two children, but received ${e.length}.`);return(0,t.jsxs)(r.A,{groupId:"synced-build-script-tabs",children:[(0,t.jsx)(l.A,{label:"build.sh",value:"build-sh",children:e[0]}),(0,t.jsx)(l.A,{label:"bld.bat",value:"bld-bat",children:e[1]})]})}const d={title:"Cross-compilation"},h=void 0,u={},p=[{value:"Terminology",id:"terminology",level:2},{value:"How to enable cross-compilation",id:"how-to-enable-cross-compilation",level:2},{value:"Placing requirements in build or host",id:"placing-requirements-in-build-or-host",level:2},{value:"Testing",id:"testing",level:2},{value:"Cross-compilation examples",id:"cross-compilation-examples",level:2},{value:"Autotools",id:"autotools",level:3},{value:"CMake",id:"cmake",level:3},{value:"Meson",id:"meson",level:3},{value:"Python",id:"python",level:3},{value:"MPI",id:"mpi",level:3},{value:"Other examples",id:"other-examples",level:3},{value:"Finding NumPy in cross-compiled Python packages using CMake",id:"finding-numpy-in-cross-compiled-python-packages-using-cmake",level:2},{value:"Details about cross-compiled Python packages",id:"details-about-cross-compiled-python-packages",level:2}];function m(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Cross-compiling means building a package for a different architecture or a different operating\nsystem than the one the build process is running on. It is a common way of obtaining packages for an\narchitecture that conda-forge does not provide any runners for (the other available technique is\n",(0,t.jsx)(n.a,{href:"/docs/maintainer/knowledge_base/#emulated-builds",children:"emulation"}),"). Given how abundant x86_64 runners\nare, most common cross-compilation setups will target non-x86_64 architectures from x86_64 runners."]}),"\n",(0,t.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,t.jsx)(n.p,{children:"Cross-compilation terminology usually distinguishes between two types of platform:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Build: The platform running the building process."}),"\n",(0,t.jsx)(n.li,{children:"Host: The platform we are building packages for."}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.p,{children:"Some cross-compilation documentation might also distinguish between a third type of platform, the\ntarget platform. This is used primarily when building cross-compilers, and indicates the platform\nfor which the built package will generate code for. For the purposes of this documentation, we'll\nconsider this to be irrelevant and the target platform to be the same as the host."}),(0,t.jsx)(n.p,{children:'Note that some resources may use the term "host" to refer to the build platform, and the term\n"target" to refer to the host platform. This convention is notably used by cmake, but we will not use this convention in this document.'})]}),"\n",(0,t.jsx)(n.h2,{id:"how-to-enable-cross-compilation",children:"How to enable cross-compilation"}),"\n",(0,t.jsxs)(n.p,{children:["By default, the build scripts only enable building for platforms that feature native conda-forge\nrunners. To enable cross-compilation, you need to extend the\n",(0,t.jsx)(n.a,{href:"/docs/maintainer/conda_forge_yml/#build-platform",children:"build_platform"})," mapping in ",(0,t.jsx)(n.code,{children:"conda-forge.yml"}),"\nthat specifies which build platform to use to cross-compile for a specific platform."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, to cross-compile ",(0,t.jsx)(n.code,{children:"linux-aarch64"})," and ",(0,t.jsx)(n.code,{children:"linux-ppc64le"})," from ",(0,t.jsx)(n.code,{children:"linux-64"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"build_platform:\n  linux_aarch64: linux_64\n  linux_ppc64le: linux_64\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Then ",(0,t.jsx)(n.a,{href:"/docs/how-to/basics/rerender/",children:"rerender"})," the feedstock. This will generate the appropriate CI workflows and\nconda-build input metadata. The ",(0,t.jsx)(n.a,{href:"/docs/maintainer/conda_forge_yml/#test",children:"test"})," key can be used to skip the test phase when\ncross-compiling, if necessary. Provided the requirements metadata and build scripts are written correctly, the\npackage should just work. However, in some cases, it'll need some adjustments; see examples below\nfor some common cases."]}),"\n",(0,t.jsx)(n.p,{children:"The used platforms are exposed in recipes as selectors and in the build scripts as environment\nvariables. For v1 recipes, the following variables are used:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"build_platform"}),": The platform on which ",(0,t.jsx)(n.code,{children:"conda-build"})," is running, corresponding to the ",(0,t.jsx)(n.code,{children:"build"}),"\nenvironment that is made available in ",(0,t.jsx)(n.code,{children:"$BUILD_PREFIX"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"host_platform"}),": The platform on which the package will be installed, corresponding to the ",(0,t.jsx)(n.code,{children:"host"}),"\nenvironment that is made available in ",(0,t.jsx)(n.code,{children:"$PREFIX"}),". For native builds, matches ",(0,t.jsx)(n.code,{children:"build_platform"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In v0 recipes, ",(0,t.jsx)(n.code,{children:"target_platform"})," is used in place of ",(0,t.jsx)(n.code,{children:"host_platform"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["As a result of 1:1 conversion from v0 recipes, many existing v1 recipes are using ",(0,t.jsx)(n.code,{children:"target_platform"}),"\ninstead of ",(0,t.jsx)(n.code,{children:"host_platform"}),". This works because target platform is almost always the same as host\nplatform, though it is technically incorrect."]})}),"\n",(0,t.jsxs)(n.p,{children:["In addition to these two variables, there are some more environment variables that are set by\nconda-forge's automation (e.g. ",(0,t.jsx)(n.code,{children:"conda-forge-ci-setup"}),", compiler activation packages, etc) that\ncan aid in cross-compilation setups:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CONDA_BUILD_CROSS_COMPILATION"}),": set to ",(0,t.jsx)(n.code,{children:"1"})," when the build platform and the host platform differ."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CONDA_TOOLCHAIN_BUILD"}),": the autoconf triplet expected for build platform."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CONDA_TOOLCHAIN_HOST"}),": the autoconf triplet expected for host platform."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CMAKE_ARGS"}),": arguments needed to cross-compile with CMake. Pass it to ",(0,t.jsx)(n.code,{children:"cmake"})," in your build\nscript."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MESON_ARGS"}),": arguments needed to cross-compile with Meson. Pass it to ",(0,t.jsx)(n.code,{children:"meson"})," in your build\nscript. Note a ",(0,t.jsx)(n.a,{href:"https://mesonbuild.com/Cross-compilation.html",children:"cross build definition file"})," is\nautomatically created for you too."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CC_FOR_BUILD"}),": a C compiler targeting the build platform."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CXX_FOR_BUILD"}),": a C++ compiler targeting the build platform."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CROSSCOMPILING_EMULATOR"}),": Path to the ",(0,t.jsx)(n.code,{children:"qemu"})," binary for the host platform. Useful for running\ntests when cross-compiling."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This is all supported by two main conda-build features introduced in version 3:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["How ",(0,t.jsx)(n.a,{href:"https://docs.conda.io/projects/conda-build/en/latest/resources/define-metadata.html#requirements-section",children:"requirements metadata"}),"\nis expressed in ",(0,t.jsx)(n.code,{children:"meta.yaml"}),", which distinguishes between ",(0,t.jsx)(n.code,{children:"build"})," and ",(0,t.jsx)(n.code,{children:"host"})," platforms."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"compiler()"})," Jinja function and underlying ",(0,t.jsx)(n.a,{href:"https://docs.conda.io/projects/conda-build/en/latest/resources/compiler-tools.html",children:"conventions for the compiler packages"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"placing-requirements-in-build-or-host",children:"Placing requirements in build or host"}),"\n",(0,t.jsxs)(n.p,{children:["The dependencies that need to be present during the build process need to be split between the\n",(0,t.jsx)(n.code,{children:"build"})," and ",(0,t.jsx)(n.code,{children:"host"})," requirement sections, corresponding appropriately to the build and host\nenvironments."]}),"\n",(0,t.jsx)(n.p,{children:"The rule of thumb for splitting them is:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If the package provides binaries that need to be run during the build process, it goes into\n",(0,t.jsx)(n.code,{children:"build"}),". Examples include the compiler, ",(0,t.jsx)(n.code,{children:"make"}),", ",(0,t.jsx)(n.code,{children:"meson"}),", ",(0,t.jsx)(n.code,{children:"pkg-config"}),", ",(0,t.jsx)(n.code,{children:"sed"})," and so on."]}),"\n",(0,t.jsxs)(n.li,{children:["If the package provides libraries or headers that are used to build the installed binaries or the\ntest suite, it goes into ",(0,t.jsx)(n.code,{children:"host"}),". Examples include ",(0,t.jsx)(n.code,{children:"eigen"}),", ",(0,t.jsx)(n.code,{children:"libxml2-devel"}),", ",(0,t.jsx)(n.code,{children:"zlib"})," and so on. For\nhistorical reasons, ",(0,t.jsx)(n.code,{children:"python"})," also belongs in ",(0,t.jsx)(n.code,{children:"host"})," dependencies, but see ",(0,t.jsx)(n.a,{href:"#details-about-cross-compiled-python-packages",children:"Python\ncross-compilation"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If both conditions are true, the package belongs in both sections (in the ",(0,t.jsx)(n.code,{children:"build"})," section, it may\nneed to be made conditional to cross-compiling). An example of such a package is ",(0,t.jsx)(n.code,{children:"llvmdev"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Note that these rules are oversimplified. For example, if additional binaries need to be compiled\nthat are used only during the build, their dependencies go into the ",(0,t.jsx)(n.code,{children:"build"})," section as well."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Conda builds are using the ",(0,t.jsx)(n.code,{children:"${BUILD_PREFIX}"})," / ",(0,t.jsx)(n.code,{children:"${PREFIX}"})," split even when not cross-compiling,\ntherefore splitting the dependencies correctly is always necessary. However, the non\ncross-compilation cases are generally more tolerant of errors, such as running binaries from\n",(0,t.jsx)(n.code,{children:"${PREFIX}"})," or building against libraries in ",(0,t.jsx)(n.code,{children:"${BUILD_PREFIX}"}),"."]})}),"\n",(0,t.jsx)(n.p,{children:"In some cases, additional packages may be needed only when cross-compiling. To cover that, you can\nuse an appropriate selectors to cover for the build platform and the host platform being different.\nThese are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["for v0 recipes, ",(0,t.jsx)(n.code,{children:"[build_platform != target_platform]"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["for v1 recipes, ",(0,t.jsx)(n.code,{children:"if: build_platform != host_platform"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["However, there are some cases requiring special handling; most notably ",(0,t.jsx)(n.a,{href:"#details-about-cross-compiled-python-packages",children:"Python cross-compilation"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,t.jsx)(n.p,{children:"Running the test suites of the packages generally requires executing binaries built for the host\nplatform. To accommodate this, build environments usually provide a emulator. However, recipes must\nnot rely on that, and be able to build successfully without the emulator being provided. The build\nscript commands relying on the emulator being available need to be guarded using the following\ncondition:"}),"\n",(0,t.jsxs)(c,{children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'if [[ "${CONDA_BUILD_CROSS_COMPILATION:-}" != "1" || "${CROSSCOMPILING_EMULATOR:-}" != "" ]]; then\n  ...\nfi\n'})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-batch",children:'if not "%CONDA_BUILD_SKIP_TESTS%"=="1" (\n  ...\n)\n'})})]}),"\n",(0,t.jsxs)(n.p,{children:["There is no equivalent selector for recipes, all dependencies of unit tests should be placed in the\n",(0,t.jsx)(n.code,{children:"host"})," section unconditionally."]}),"\n",(0,t.jsx)(n.h2,{id:"cross-compilation-examples",children:"Cross-compilation examples"}),"\n",(0,t.jsx)(n.p,{children:"A package needs to make a few changes in their recipe to be compatible with cross-compilation. Here\nare a few examples."}),"\n",(0,t.jsx)(n.h3,{id:"autotools",children:"Autotools"}),"\n",(0,t.jsx)(n.p,{children:"A simple C library using autotools for cross-compilation might look like this:"}),"\n",(0,t.jsxs)(a,{children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'requirements:\n  build:\n    - {{ compiler("c") }}\n    - {{ stdlib("c") }}\n    - make\n    - pkg-config\n    - gnuconfig\n  host:\n    - libogg\n'})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'requirements:\n  build:\n    - ${{ compiler("c") }}\n    - ${{ stdlib("c") }}\n    - make\n    - pkg-config\n    - gnuconfig\n  host:\n    - libogg\n'})})]}),"\n",(0,t.jsx)(n.p,{children:"In the build script, it would need to update the config files and guard any tests when\ncross-compiling:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# Get an updated config.sub and config.guess\ncp $BUILD_PREFIX/share/gnuconfig/config.* .\n\n./configure\nmake -j${CPU_COUNT}\n\n# Skip ``make check`` when cross-compiling\nif [[ "${CONDA_BUILD_CROSS_COMPILATION:-}" != "1" || "${CROSSCOMPILING_EMULATOR:-}" != "" ]]; then\n  make check -j${CPU_COUNT}\nfi\n'})}),"\n",(0,t.jsx)(n.p,{children:"If the configure scripts needs to run programs in order to determine the system features, it will\nfail indicating that you need to provide the appropriate check results for the host platform. This\ncan be done, for example, by setting the respective environment variables prior to running\nconfigure:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'if [[ "${CONDA_BUILD_CROSS_COMPILATION:-}" == "1" && "${CROSSCOMPILING_EMULATOR:-}" == "" ]]; then\n    export gl_cv_func_getgroups_works=yes\n    export gl_cv_func_gettimeofday_clobber=no\nfi\n\n./configure\n'})}),"\n",(0,t.jsx)(n.h3,{id:"cmake",children:"CMake"}),"\n",(0,t.jsx)(n.p,{children:"A simple C++ library using CMake for cross-compilation might look like this:"}),"\n",(0,t.jsxs)(a,{children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'requirements:\n  build:\n    - {{ compiler("cxx") }}\n    - {{ stdlib("c") }}\n    - cmake\n    - ninja\n  host:\n    - libboost-devel\n'})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'requirements:\n  build:\n    - ${{ compiler("cxx") }}\n    - ${{ stdlib("c") }}\n    - cmake\n    - ninja\n  host:\n    - libboost-devel\n'})})]}),"\n",(0,t.jsxs)(n.p,{children:["In the build script, it would need to update ",(0,t.jsx)(n.code,{children:"cmake"})," call and guard any tests when cross-compiling:"]}),"\n",(0,t.jsxs)(c,{children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'if [[ "${CONDA_BUILD_CROSS_COMPILATION:-}" == 1 && "${CMAKE_CROSSCOMPILING_EMULATOR:-}" == "" ]]; then\n  # Assume that netcdf works\n  export CMAKE_ARGS="${CMAKE_ARGS} -DNetCDF_F90_WORKS_EXITCODE=0"\nfi\n\n# Pass ``CMAKE_ARGS`` to ``cmake``\ncmake ${CMAKE_ARGS} -G Ninja ..\ncmake --build .\n\n# Skip ``ctest`` when cross-compiling\nif [[ "${CONDA_BUILD_CROSS_COMPILATION:-}" != "1" || "${CROSSCOMPILING_EMULATOR:-}" != "" ]]; then\n  ctest\nfi\n'})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-batch",children:'if "%CONDA_BUILD_SKIP_TESTS%"=="1" (\n  :: Assume that netcdf works\n  set CMAKE_ARGS=%CMAKE_ARGS% -DNetCDF_F90_WORKS_EXITCODE=0\n)\n\n:: Pass ``CMAKE_ARGS`` to ``cmake``\ncmake %CMAKE_ARGS% -G Ninja ..\ncmake --build .\n\n:: Skip ``ctest`` when cross-compiling\nif not "%CONDA_BUILD_SKIP_TESTS%"=="1" (\n  ctest\n)\n'})})]}),"\n",(0,t.jsx)(n.h3,{id:"meson",children:"Meson"}),"\n",(0,t.jsxs)(n.p,{children:["Similarly, with Meson, the ",(0,t.jsx)(n.code,{children:"meta.yaml"})," needs:"]}),"\n",(0,t.jsxs)(a,{children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'requirements:\n  build:\n    - {{ compiler("c") }}\n    - {{ compiler("cxx") }}\n    - {{ stdlib("c") }}\n    - meson\n    - pkg-config\n  host:\n    - libogg\n'})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'requirements:\n  build:\n    - ${{ compiler("c") }}\n    - ${{ compiler("cxx") }}\n    - ${{ stdlib("c") }}\n    - meson\n    - pkg-config\n  host:\n    - libogg\n'})})]}),"\n",(0,t.jsx)(n.p,{children:"And this in the build script:"}),"\n",(0,t.jsxs)(c,{children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Pass ``MESON_ARGS`` to ``meson``\nmeson setup ${MESON_ARGS} ..\nmeson compile\n"})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-batch",children:":: Pass ``MESON_ARGS`` to ``meson``\nmeson setup %MESON_ARGS% ..\nmeson compile\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["Additional properties or program paths may need to be written to a cross-file. Meson accepts\nmultiple ",(0,t.jsx)(n.code,{children:"--cross-file"})," arguments, so you may add one in addition the one preprovided by compiler\nactivation scripts:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'if [[ "${CONDA_BUILD_CROSS_COMPILATION:-}" == 1 && "${CMAKE_CROSSCOMPILING_EMULATOR:-}" == "" ]]; then\n    cat > local-cross-file.txt <<-EOF\n        [binaries]\n        glib-mkenums = \'${BUILD_PREFIX}/bin/glib-mkenums\'\n\n        [properties]\n        longdouble_format = \'IEEE_DOUBLE_LE\'\n    EOF\n\n    MESON_ARGS+=" --cross-file ${PWD}/local-cross-file.txt"\nfi\n'})}),"\n",(0,t.jsx)(n.h3,{id:"python",children:"Python"}),"\n",(0,t.jsx)(n.p,{children:"A simple Python extension using Cython and NumPy's C API would look like so:"}),"\n",(0,t.jsxs)(a,{children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'requirements:\n  build:\n    - {{ compiler("c") }}\n    - {{ stdlib("c") }}\n    - cross-python_{{ target_platform }}    # [build_platform != target_platform]\n    - python                                # [build_platform != target_platform]\n    - cython                                # [build_platform != target_platform]\n    - numpy                                 # [build_platform != target_platform]\n  host:\n    - python\n    - pip\n    - cython\n    - numpy\n  run:\n    - python\n'})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'requirements:\n  build:\n    - ${{ compiler("c") }}\n    - ${{ stdlib("c") }}\n    - if: build_platform != host_platform\n      then:\n        - cross-python_${{ host_platform }}\n        - python\n        - cython\n        - numpy\n  host:\n    - python\n    - pip\n    - cython\n    - numpy\n  run:\n    - python\n'})})]}),"\n",(0,t.jsxs)(n.p,{children:["This example is discussed in greater detail in ",(0,t.jsx)(n.a,{href:"#details-about-cross-compiled-python-packages",children:"details about cross-compiled Python\npackages"}),".\nFor more details about NumPy see ",(0,t.jsx)(n.a,{href:"/docs/maintainer/knowledge_base/#building-against-numpy",children:"Building against NumPy"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"mpi",children:"MPI"}),"\n",(0,t.jsxs)(n.p,{children:["With MPI, openmpi is required for the build platform as the compiler wrappers are binaries, but mpich is not required as the compiler wrappers are scripts (see ",(0,t.jsx)(n.a,{href:"https://github.com/conda-forge/mpi4py-feedstock/blob/743d379c4a04/recipe/meta.yaml#L37",children:"example"}),"):"]}),"\n",(0,t.jsxs)(a,{children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'requirements:\n  build:\n    - {{ mpi }}  # [build_platform != target_platform and mpi == "openmpi"]\n  host:\n    - {{ mpi }}\n  run:\n    - {{ mpi }}\n'})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'requirements:\n  build:\n    - if: build_platform != host_platform and mpi == "openmpi"\n      then: ${{ mpi }}\n  host:\n    - ${{ mpi }}\n  run:\n    - ${{ mpi }}\n'})})]}),"\n",(0,t.jsxs)(n.p,{children:["In the build script, openmpi compiler wrappers can use host libraries by setting the environmental variable ",(0,t.jsx)(n.code,{children:"OPAL_PREFIX"})," to ",(0,t.jsx)(n.code,{children:"$PREFIX"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:'if [[ "$CONDA_BUILD_CROSS_COMPILATION" == "1" && "${mpi}" == "openmpi" ]]; then\n  export OPAL_PREFIX="$PREFIX"\nfi\n'})}),"\n",(0,t.jsx)(n.h3,{id:"other-examples",children:"Other examples"}),"\n",(0,t.jsxs)(n.p,{children:["There are more variations of this approach in the wild. So this is not meant to be exhaustive,\nbut merely to provide a starting point with some guidelines. Please look at ",(0,t.jsx)(n.a,{href:"https://github.com/search?q=org%3Aconda-forge+path%3Arecipe%2Fmeta.yaml+%22%5Bbuild_platform+%21%3D+target_platform%5D%22&type=code",children:"other recipes for more examples"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"finding-numpy-in-cross-compiled-python-packages-using-cmake",children:"Finding NumPy in cross-compiled Python packages using CMake"}),"\n",(0,t.jsx)(n.p,{children:"If you are building a Python extension via CMake with NumPy and you want it to work in\ncross-compilation, you need to prepend to the CMake invocation in your build script the following\nlines:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:'Python_INCLUDE_DIR="$(python -c \'import sysconfig; print(sysconfig.get_path("include"))\')"\nPython_NumPy_INCLUDE_DIR="$(python -c \'import numpy; print(numpy.get_include())\')"\n# usually either Python_* or Python3_* lines are sufficient\nCMAKE_ARGS+=" -DPython_EXECUTABLE:PATH=${PYTHON}"\nCMAKE_ARGS+=" -DPython_INCLUDE_DIR:PATH=${Python_INCLUDE_DIR}"\nCMAKE_ARGS+=" -DPython_NumPy_INCLUDE_DIR=${Python_NumPy_INCLUDE_DIR}"\nCMAKE_ARGS+=" -DPython3_EXECUTABLE:PATH=${PYTHON}"\nCMAKE_ARGS+=" -DPython3_INCLUDE_DIR:PATH=${Python_INCLUDE_DIR}"\nCMAKE_ARGS+=" -DPython3_NumPy_INCLUDE_DIR=${Python_NumPy_INCLUDE_DIR}"\n'})}),"\n",(0,t.jsx)(n.h2,{id:"details-about-cross-compiled-python-packages",children:"Details about cross-compiled Python packages"}),"\n",(0,t.jsxs)(n.p,{children:["Cross-compiling Python packages is a bit more involved than other packages. The main pain point is\nthat we need an executable Python interpreter (i.e. ",(0,t.jsx)(n.code,{children:"python"})," in ",(0,t.jsx)(n.code,{children:"build"}),") that knows how to\nprovide accurate information about the target platform. Since this is not officially supported, a\nseries of workarounds are required to make it work."]}),"\n",(0,t.jsx)(n.p,{children:"In practical terms, it means that in conda-forge you need to:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Add ",(0,t.jsx)(n.code,{children:"cross-python_${{ host_platform }}"})," (or ",(0,t.jsx)(n.code,{children:"cross-python_{{ target_platform }}"})," for v0 recipes)\nto ",(0,t.jsx)(n.code,{children:"build"})," requirements, conditionally to the cross-compiling selector."]}),"\n",(0,t.jsxs)(n.li,{children:["Copy ",(0,t.jsx)(n.code,{children:"python"})," itself and non-pure Python packages (i.e. these that ship compiled extensions)\nthat need to be present while the package is being built, such as ",(0,t.jsx)(n.code,{children:"cython"})," and ",(0,t.jsx)(n.code,{children:"numpy"}),", from\n",(0,t.jsx)(n.code,{children:"host"})," to ",(0,t.jsx)(n.code,{children:"build"})," requirements, conditionally to the cross-compiling selector."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This is demonstrated in the ",(0,t.jsx)(n.a,{href:"#python",children:"Python example"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Since Python historically did not support cross-compilation, it always needs to be present in ",(0,t.jsx)(n.code,{children:"host"}),"\nrequirements, even though it is technically run during the build process."]})})]})}function f(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},19365:(e,n,i)=>{i.d(n,{A:()=>r});i(96540);var s=i(34164);const t={tabItem:"tabItem_Ymn6"};var o=i(74848);function r({children:e,hidden:n,className:i}){return(0,o.jsx)("div",{role:"tabpanel",className:(0,s.A)(t.tabItem,i),hidden:n,children:e})}},11470:(e,n,i)=>{i.d(n,{A:()=>I});var s=i(96540),t=i(34164),o=i(17559),r=i(23104),l=i(56347),a=i(205),c=i(57485),d=i(31682),h=i(70679);function u(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:i}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return u(e).map((({props:{value:e,label:n,attributes:i,default:s}})=>({value:e,label:n,attributes:i,default:s})))}(i);return function(e){const n=(0,d.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,i])}function m({value:e,tabValues:n}){return n.some((n=>n.value===e))}function f({queryString:e=!1,groupId:n}){const i=(0,l.W6)(),t=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(t),(0,s.useCallback)((e=>{if(!t)return;const n=new URLSearchParams(i.location.search);n.set(t,e),i.replace({...i.location,search:n.toString()})}),[t,i])]}function g(e){const{defaultValue:n,queryString:i=!1,groupId:t}=e,o=p(e),[r,l]=(0,s.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const i=n.find((e=>e.default))??n[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:o}))),[c,d]=f({queryString:i,groupId:t}),[u,g]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[i,t]=(0,h.Dv)(n);return[i,(0,s.useCallback)((e=>{n&&t.set(e)}),[n,t])]}({groupId:t}),x=(()=>{const e=c??u;return m({value:e,tabValues:o})?e:null})();(0,a.A)((()=>{x&&l(x)}),[x]);return{selectedValue:r,selectValue:(0,s.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),g(e)}),[d,g,o]),tabValues:o}}var x=i(92303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var j=i(74848);function y({className:e,block:n,selectedValue:i,selectValue:s,tabValues:o}){const l=[],{blockElementScrollPositionUntilNextRender:a}=(0,r.a_)(),c=e=>{const n=e.currentTarget,t=l.indexOf(n),r=o[t].value;r!==i&&(a(n),s(r))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const i=l.indexOf(e.currentTarget)+1;n=l[i]??l[0];break}case"ArrowLeft":{const i=l.indexOf(e.currentTarget)-1;n=l[i]??l[l.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":n},e),children:o.map((({value:e,label:n,attributes:s})=>(0,j.jsx)("li",{role:"tab",tabIndex:i===e?0:-1,"aria-selected":i===e,ref:e=>{l.push(e)},onKeyDown:d,onClick:c,...s,className:(0,t.A)("tabs__item",b.tabItem,s?.className,{"tabs__item--active":i===e}),children:n??e},e)))})}function _({lazy:e,children:n,selectedValue:i}){const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=o.find((e=>e.props.value===i));return e?(0,s.cloneElement)(e,{className:(0,t.A)("margin-top--md",e.props.className)}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function v(e){const n=g(e);return(0,j.jsxs)("div",{className:(0,t.A)(o.G.tabs.container,"tabs-container",b.tabList),children:[(0,j.jsx)(y,{...n,...e}),(0,j.jsx)(_,{...n,...e})]})}function I(e){const n=(0,x.A)();return(0,j.jsx)(v,{...e,children:u(e.children)},String(n))}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var s=i(96540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);