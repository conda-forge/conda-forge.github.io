import { useState, useEffect } from "react";
import { Resolver } from "@stoplight/json-ref-resolver";
import Heading from "@theme/Heading";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import CodeBlock from "@theme/CodeBlock";
import Admonition from "@theme/Admonition";

export default function CondaForgeYmlSchema() {
  const [resolvedSchema, setResolvedSchema] = useState();
  const schemaURL =
    "https://raw.githubusercontent.com/viniciusdc/conda-smithy/pydantic-schema-cf-yaml/conda_smithy/data/conda-forge.json";

  useEffect(() => {
    fetch(schemaURL, {
      headers: {
        Accept: "application/json",
      },
    })
      .then((response) => response.json())
      .then((rawSchema) => new Resolver().resolve(rawSchema, {}))
      .then((resolved) => {
        setResolvedSchema(resolved.result);
      });
  }, []);

  if (!resolvedSchema) {
    return <div>Loading...</div>;
  }

  return (
    <>
      <Admonition type="info">
        This documentation autogenerated from{" "}
        <a href={schemaURL} target="_blank">
          conda-smithy's JSON Schema
        </a>
        . Types and accepted values are note rendered here for simplicity, but
        the the linters will use the full schema to validate your feedstock
        configuration.
      </Admonition>
      <SchemaToc schema={resolvedSchema} />
      <Markdown>{resolvedSchema.description}</Markdown>
      <p></p>
      {Object.entries(resolvedSchema.properties)
        .sort()
        .map(([key, value]) => (
          <Setting key={key} name={key} value={value} />
        ))}
    </>
  );
}

function SchemaToc({ schema }) {
  return (
    <ul>
      {Object.entries(schema.properties)
        .sort()
        .map(([key, value]) => (
          <li key={key}>
            <a href={`#${key}`} key={key}>
              {(value.deprecated && (
                <span style={{ textDecoration: "line-through" }}>{key}</span>
              )) ||
                key}
            </a>
          </li>
        ))}
    </ul>
  );
}

function Setting({ name, value, level = 1 }) {
  return (
    <>
      <Heading as={`h${level + 2}`} id={name}>
        {(value.deprecated && (
          <span style={{ textDecoration: "line-through" }}>{name}</span>
        )) ||
          name}
      </Heading>
      {value.deprecated && (
        <p>
          <span className={["badge", "badge--danger"].join(" ")}>
            Deprecated
          </span>
        </p>
      )}
      <Markdown>{value.description.trim()}</Markdown>
      {value.examples && (
        <details>
          <summary>Examples</summary>
          <Markdown>{value.examples.join(", ")}</Markdown>
        </details>
      )}
    </>
  );
}

function Type({ value }) {
  var types = [];
  var options = [];
  var subkeys = [];
  value.anyOf.map((v) => {
    if (v.type && v.type != "null") {
      types.push(v.type);
    }
    // if (v.type === "object") {
    //   v.properties.foreach((p) => {
    //     subkeys.push()
    //   };
    // }
    if (v.enum) {
      options.push(...v.enum);
    }
  });
  return (
    <>
      {types.length ? (
        <>
          <strong>Accepted types: </strong>
          <span>
            {types.map((t) => (
              <code>{t}</code>
            ))}
          </span>
        </>
      ) : null}
      {options.length ? (
        <>
          <br />
          Options:{" "}
          <span>
            {options.map((o) => (
              <>
                <code>{o}</code>{" "}
              </>
            ))}
          </span>
        </>
      ) : null}
      {value.default && (
        <p>
          Default: <code>{value.default}</code>
        </p>
      )}
    </>
  );
}

const Markdown = ({ children }) => (
  <ReactMarkdown
    remarkPlugins={[remarkGfm]}
    components={{
      pre(props) {
        const { children, className, node, ...rest } = props;
        if (children && children.props.node.tagName == "code") {
          return <div>{children}</div>;
        }
        return node;
      },
      code(props) {
        const { children, className, node, ...rest } = props;
        const match = /language-(\w+)/.exec(className || "");
        if (!match) {
          return <code {...rest} className={className} children={children} />;
        }
        if (["info", "error", "warning", "danger"].includes(match[1])) {
          return <Admonition type={match[1]} children={children} />;
        } else {
          return (
            <CodeBlock {...rest} children={children} language={match[1]} />
          );
        }
      },
    }}
  >
    {children}
  </ReactMarkdown>
);
